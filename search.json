[
  {
    "objectID": "hierarchy.html",
    "href": "hierarchy.html",
    "title": "Hierarchy Scores",
    "section": "",
    "text": "Biological signaling can be modeled as a directed network, where nodes represent genes/proteins and edges represent signaling interactions.\nThe hierarchy of such a network can be quantified using various metrics, including the Krackhardt hierarchy score. This score measures the degree to which the network exhibits a perfect hierarchy, with higher scores indicating greater hierarchy.\nIn R the sna package presents methods to compute graph hierarchy including Krackhardt’s score (defined as \\(A/MaxV\\) where \\(A\\) is the number of unordered pairs of points in Dr that are asymmetrically linked), and there are other hierarchy scores implemented in Python such as Flow Hierarchy Score Luo and Magee 2011. However, despite its utility, there is currently no native implementation of the Krackhardt hierarchy score in Python.\n\n\nAs defined in Krackhardt, David. (1994). Graph Theoretical Dimensions of Informal Organization. Computational Organization Theory. 89.\nThe graph hierarchy condition states that in a digraph D, for each pair of points where one (Pi) can reach another (Pj), the second (Pj) can't reach the first (Pi). \nFor example, in a formal organization chart a high lvl employee can reach through the chain of command her subordinate's subordinate. If the formal organization is working \"properly\", this lower lvl employee can't simultaneously reach the high lvl employee.\nTo measure the degree of hierarchy of digraph D, a new digraph Dr must be created. Dr is defined as the reachability digraph of D. Each point in D exists in Dr; moreover, the line (Pi,Pj) exists in Dr if and only if Pi can reach Pj in D. If D is graph hierarchic, then Dr will have no symmetric lines in it (i.e. if the line (Pi,Pj) exists in Dr then the line (Pj,Pi) does not).\nThe degree of hierarchy then is defined as:\n\\[\n    Graph Hierarchy = 1 - [V/MaxV]\n\\] Where \\(V\\) is the number of unordered pairs of points in Dr that are symmetrically linked , and \\(MaxV\\) the number of unordered pairs of points in Dr where Pi is linked to Pj or viceversa.\n\n\nfor i in rpy2.situation.iter_info(): # Print Rpy2 info\n    print(i)\n\npandas2ri.activate()\n\nrpy2 version:\n3.5.11\nPython version:\n3.10.12 | packaged by conda-forge | (main, Jun 23 2023, 22:39:40) [Clang 15.0.7 ]\nLooking for R's HOME:\n    Environment variable R_HOME: /Users/ferran/miniconda3/envs/pykrack/lib/R\n    Calling `R RHOME`: /Users/ferran/miniconda3/envs/pykrack/lib/R\n    Environment variable R_LIBS_USER: None\nR's additions to LD_LIBRARY_PATH:\n/usr/local/lib/R/library/stats/libs/:/usr/local/lib/R/library/stats/libs/\nR version:\n    In the PATH: R version 4.3.1 (2023-06-16) -- \"Beagle Scouts\"\n    Loading R library from rpy2: OK\nAdditional directories to load R packages from:\nNone\nC extension compilation:\n  include:\n  ['/Users/ferran/miniconda3/envs/pykrack/lib/R/include']\n  libraries:\n  ['R', 'pcre2-8', 'lzma', 'bz2', 'z', 'dl', 'm', 'iconv', 'icuuc', 'icui18n']\n  library_dirs:\n  ['/Users/ferran/miniconda3/envs/pykrack/lib', '/Users/ferran/miniconda3/envs/pykrack/lib/R/lib', '/Users/ferran/miniconda3/envs/pykrack/lib']\n  extra_compile_args:\n  ['-std=c99']\n  extra_link_args:\n  ['-fopenmp', '-Wl,-dead_strip_dylibs', '-Wl,-pie', '-Wl,-headerpad_max_install_names', '-Wl,-dead_strip_dylibs', '-Wl,-rpath,/Users/ferran/miniconda3/envs/pykrack/lib']\nDirectory for the R shared library:\nlib\nCFFI extension type\n  Environment variable: RPY2_CFFI_MODE\n  Value: CFFI_MODE.ANY\n  ABI: PRESENT\n  API: PRESENT\n\n\n\nsource\n\n\n\n compute_hierarchy (G, metric='pykrack')\n\nCompute one of the possible hierarchy scores\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nG\n\n\nDirected NetworkX graph\n\n\nmetric\nstr\npykrack\nType of hierarchy metric to compute. Accepted types are:‘pykrack’ for this module’s implementation of the Krackhardt score.‘rsnakrack’ for the sna implementation in R.‘hierarchy_flow’ for the Luo and Magee 2011 as implemented in the NetworkX package.\n\n\nReturns\nfloat\n\nOne of the possible hierarchy scores\n\n\n\n\nG1 = nx.DiGraph([(1, 2), (2, 3), (1, 5), (2, 4), (4, 6), (5, 6), (3, 1)])\n\n\nG2 = nx.DiGraph([(1, 2), (2, 3), (1, 5), (2, 4), (4, 6), (5, 6)])\n\n\nG3 = nx.DiGraph([(1, 2), (4, 6)])\n\n\n#Graph from OmniPath\n#using the following link: https://omnipathdb.org/interactions?genesymbols=yes&fields=type&license=academic&directed=0\n#Gets us all interactions, no matter type nor undirected/vs directed\nomnidata = pd.read_csv(\"https://omnipathdb.org/interactions?genesymbols=yes&fields=type&license=academic&directed=1\", sep=\"\\t\")\n\nG4 = nx.from_pandas_edgelist(omnidata, source=\"source_genesymbol\", target=\"target_genesymbol\",edge_attr=\"type\", create_using=nx.DiGraph)\n\n\nG = G1\n\nprint(graph_properties(G))\n\nEdges:7, Nodes:6, Avg Degree:2.3333333333333335, Density:0.23333333333333334\n\n\nUsing product from itertools is around 4 times faster when iterating through the nodes of the Omnipath graph.\n\n# %%time\n# countlist = []\n# for i in G.nodes():\n#     for j in G.nodes():\n#         pair = [i,j]\n#         countlist.append(pair)\n\n# print(len(countlist))\n\n\n# %%time\n# countlist = []\n# for pair in product(G.nodes(), G.nodes()):\n#     countlist.append(pair)\n\n# print(len(countlist))\n\n\ncompute_hierarchy(G, metric=\"pykrack\")\n\nCPU times: user 232 µs, sys: 22 µs, total: 254 µs\nWall time: 257 µs\n\n\n0.7857142857142857\n\n\n\ncompute_hierarchy(G, metric=\"rsnakrack\")\n\nCPU times: user 972 ms, sys: 103 ms, total: 1.08 s\nWall time: 1.16 s\n\n\n0.7857142857142857\n\n\n\ncompute_hierarchy(G, metric=\"hierarchy_flow\")\n\nCPU times: user 323 µs, sys: 19 µs, total: 342 µs\nWall time: 349 µs\n\n\n0.5714285714285714"
  },
  {
    "objectID": "hierarchy.html#krackhardt-hierarchy-score",
    "href": "hierarchy.html#krackhardt-hierarchy-score",
    "title": "Hierarchy Scores",
    "section": "",
    "text": "As defined in Krackhardt, David. (1994). Graph Theoretical Dimensions of Informal Organization. Computational Organization Theory. 89.\nThe graph hierarchy condition states that in a digraph D, for each pair of points where one (Pi) can reach another (Pj), the second (Pj) can't reach the first (Pi). \nFor example, in a formal organization chart a high lvl employee can reach through the chain of command her subordinate's subordinate. If the formal organization is working \"properly\", this lower lvl employee can't simultaneously reach the high lvl employee.\nTo measure the degree of hierarchy of digraph D, a new digraph Dr must be created. Dr is defined as the reachability digraph of D. Each point in D exists in Dr; moreover, the line (Pi,Pj) exists in Dr if and only if Pi can reach Pj in D. If D is graph hierarchic, then Dr will have no symmetric lines in it (i.e. if the line (Pi,Pj) exists in Dr then the line (Pj,Pi) does not).\nThe degree of hierarchy then is defined as:\n\\[\n    Graph Hierarchy = 1 - [V/MaxV]\n\\] Where \\(V\\) is the number of unordered pairs of points in Dr that are symmetrically linked , and \\(MaxV\\) the number of unordered pairs of points in Dr where Pi is linked to Pj or viceversa.\n\n\nfor i in rpy2.situation.iter_info(): # Print Rpy2 info\n    print(i)\n\npandas2ri.activate()\n\nrpy2 version:\n3.5.11\nPython version:\n3.10.12 | packaged by conda-forge | (main, Jun 23 2023, 22:39:40) [Clang 15.0.7 ]\nLooking for R's HOME:\n    Environment variable R_HOME: /Users/ferran/miniconda3/envs/pykrack/lib/R\n    Calling `R RHOME`: /Users/ferran/miniconda3/envs/pykrack/lib/R\n    Environment variable R_LIBS_USER: None\nR's additions to LD_LIBRARY_PATH:\n/usr/local/lib/R/library/stats/libs/:/usr/local/lib/R/library/stats/libs/\nR version:\n    In the PATH: R version 4.3.1 (2023-06-16) -- \"Beagle Scouts\"\n    Loading R library from rpy2: OK\nAdditional directories to load R packages from:\nNone\nC extension compilation:\n  include:\n  ['/Users/ferran/miniconda3/envs/pykrack/lib/R/include']\n  libraries:\n  ['R', 'pcre2-8', 'lzma', 'bz2', 'z', 'dl', 'm', 'iconv', 'icuuc', 'icui18n']\n  library_dirs:\n  ['/Users/ferran/miniconda3/envs/pykrack/lib', '/Users/ferran/miniconda3/envs/pykrack/lib/R/lib', '/Users/ferran/miniconda3/envs/pykrack/lib']\n  extra_compile_args:\n  ['-std=c99']\n  extra_link_args:\n  ['-fopenmp', '-Wl,-dead_strip_dylibs', '-Wl,-pie', '-Wl,-headerpad_max_install_names', '-Wl,-dead_strip_dylibs', '-Wl,-rpath,/Users/ferran/miniconda3/envs/pykrack/lib']\nDirectory for the R shared library:\nlib\nCFFI extension type\n  Environment variable: RPY2_CFFI_MODE\n  Value: CFFI_MODE.ANY\n  ABI: PRESENT\n  API: PRESENT\n\n\n\nsource\n\n\n\n compute_hierarchy (G, metric='pykrack')\n\nCompute one of the possible hierarchy scores\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nG\n\n\nDirected NetworkX graph\n\n\nmetric\nstr\npykrack\nType of hierarchy metric to compute. Accepted types are:‘pykrack’ for this module’s implementation of the Krackhardt score.‘rsnakrack’ for the sna implementation in R.‘hierarchy_flow’ for the Luo and Magee 2011 as implemented in the NetworkX package.\n\n\nReturns\nfloat\n\nOne of the possible hierarchy scores\n\n\n\n\nG1 = nx.DiGraph([(1, 2), (2, 3), (1, 5), (2, 4), (4, 6), (5, 6), (3, 1)])\n\n\nG2 = nx.DiGraph([(1, 2), (2, 3), (1, 5), (2, 4), (4, 6), (5, 6)])\n\n\nG3 = nx.DiGraph([(1, 2), (4, 6)])\n\n\n#Graph from OmniPath\n#using the following link: https://omnipathdb.org/interactions?genesymbols=yes&fields=type&license=academic&directed=0\n#Gets us all interactions, no matter type nor undirected/vs directed\nomnidata = pd.read_csv(\"https://omnipathdb.org/interactions?genesymbols=yes&fields=type&license=academic&directed=1\", sep=\"\\t\")\n\nG4 = nx.from_pandas_edgelist(omnidata, source=\"source_genesymbol\", target=\"target_genesymbol\",edge_attr=\"type\", create_using=nx.DiGraph)\n\n\nG = G1\n\nprint(graph_properties(G))\n\nEdges:7, Nodes:6, Avg Degree:2.3333333333333335, Density:0.23333333333333334\n\n\nUsing product from itertools is around 4 times faster when iterating through the nodes of the Omnipath graph.\n\n# %%time\n# countlist = []\n# for i in G.nodes():\n#     for j in G.nodes():\n#         pair = [i,j]\n#         countlist.append(pair)\n\n# print(len(countlist))\n\n\n# %%time\n# countlist = []\n# for pair in product(G.nodes(), G.nodes()):\n#     countlist.append(pair)\n\n# print(len(countlist))\n\n\ncompute_hierarchy(G, metric=\"pykrack\")\n\nCPU times: user 232 µs, sys: 22 µs, total: 254 µs\nWall time: 257 µs\n\n\n0.7857142857142857\n\n\n\ncompute_hierarchy(G, metric=\"rsnakrack\")\n\nCPU times: user 972 ms, sys: 103 ms, total: 1.08 s\nWall time: 1.16 s\n\n\n0.7857142857142857\n\n\n\ncompute_hierarchy(G, metric=\"hierarchy_flow\")\n\nCPU times: user 323 µs, sys: 19 µs, total: 342 µs\nWall time: 349 µs\n\n\n0.5714285714285714"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pyKrack",
    "section": "",
    "text": "Due to the comparisons with the R package sna we recommend using conda to manage your environment.\n\nFirst create the pykrack conda environment from the environment.yml file:\n\nconda (or mamba) env create -f environment.yml\n\nThen load the conda environment with:\n\nconda activate pykrack\n\nAnd finally install the package from pip via the following command:\n\npip install pyKrack\nAlternatively pyKrack can also be isntalled using pip via the following command\npip install pyKrack\nThen install the R dependencies listed in the conda environmnet.yml manually."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "pyKrack",
    "section": "",
    "text": "Due to the comparisons with the R package sna we recommend using conda to manage your environment.\n\nFirst create the pykrack conda environment from the environment.yml file:\n\nconda (or mamba) env create -f environment.yml\n\nThen load the conda environment with:\n\nconda activate pykrack\n\nAnd finally install the package from pip via the following command:\n\npip install pyKrack\nAlternatively pyKrack can also be isntalled using pip via the following command\npip install pyKrack\nThen install the R dependencies listed in the conda environmnet.yml manually."
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "pyKrack",
    "section": "How to use",
    "text": "How to use\nPlease see the core and hierarchy notebooks for more detailed explanations.\npyKrack consists of one main function, compute_hierarchy.\n\nsource\n\ncompute_hierarchy\n\n compute_hierarchy (G, metric='pykrack')\n\nCompute one of the possible hierarchy scores\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nG\n\n\nDirected NetworkX graph\n\n\nmetric\nstr\npykrack\nType of hierarchy metric to compute. Accepted types are:‘pykrack’ for this module’s implementation of the Krackhardt score.‘rsnakrack’ for the sna implementation in R.‘hierarchy_flow’ for the Luo and Magee 2011 as implemented in the NetworkX package.\n\n\nReturns\nfloat\n\nOne of the possible hierarchy scores"
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Utils",
    "section": "",
    "text": "The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n\n\nThis wrapper function spits out some basic graph properties of a NetworkX graph object. We can use it to conveniently explore the different graphs on which to compute hierarchy scores.\n\nsource\n\ngraph_properties\n\n graph_properties (G)\n\nReturn the properties of a NetworkX graph.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nG\n\nNetworkX graph\n\n\nReturns\nstr\nConcatenated string with number of edges and of nodes, the average degree and the graph’s density\n\n\n\nLet’s test it on a simple directed graph.\nFirst we wil define the graph and visualise it using Graphviz\n\nG1 = nx.DiGraph([(1, 2), (2, 3), (1, 5), (2, 4), (4, 6), (5, 6), (3, 1)])\n\n\n\n\n\n\n\n\n\nG\n\n  \n\n1\n\n 1   \n\n2\n\n 2   \n\n1-&gt;2\n\n    \n\n5\n\n 5   \n\n1-&gt;5\n\n    \n\n3\n\n 3   \n\n2-&gt;3\n\n    \n\n4\n\n 4   \n\n2-&gt;4\n\n    \n\n3-&gt;1\n\n    \n\n6\n\n 6   \n\n5-&gt;6\n\n    \n\n4-&gt;6\n\n   \n\n\n\n\n\n\nAnd now we can print the output of graph_properties\n\nprint(graph_properties(G1))\n\nassert graph_properties(G1)==\"Edges:7, Nodes:6, Avg Degree:2.3333333333333335, Density:0.23333333333333334\"\n\nEdges:7, Nodes:6, Avg Degree:2.3333333333333335, Density:0.23333333333333334\n\n\nWe can also check out some other hand-defined directed graphs, a digraph built from the OmniPath database or a NetworkX built-in graph.\n\nG2 = nx.DiGraph([(1, 2), (2, 3), (1, 5), (2, 4), (4, 6), (5, 6)])\n\n\nG3 = nx.DiGraph([(1, 2), (4, 6)])\n\n\n# Directed Graph from OmniPath\n#using the following link: https://omnipathdb.org/interactions?genesymbols=yes&fields=type&license=academic&directed=0\n#Gets us all interactions, no matter type nor undirected/vs directed\nomnidata = pd.read_csv(\"https://omnipathdb.org/interactions?genesymbols=yes&fields=type&license=academic&directed=1\", sep=\"\\t\")\n\nG4 = nx.from_pandas_edgelist(omnidata, source=\"source_genesymbol\", target=\"target_genesymbol\",edge_attr=\"type\", create_using=nx.DiGraph)\n\n\n# Graph from Krackhardt's work on centrality metrics (Krackhardt, David 1990)\nG5 = nx.krackhardt_kite_graph()\n\n\nprint(graph_properties(G1))\nprint(graph_properties(G2))\nprint(graph_properties(G3))\nprint(graph_properties(G4))\nprint(graph_properties(G5))\n\nEdges:7, Nodes:6, Avg Degree:2.3333333333333335, Density:0.23333333333333334\nEdges:6, Nodes:6, Avg Degree:2.0, Density:0.2\nEdges:2, Nodes:4, Avg Degree:1.0, Density:0.16666666666666666\nEdges:91888, Nodes:9248, Avg Degree:19.8719723183391, Density:0.0010745091553119445\nEdges:18, Nodes:10, Avg Degree:3.6, Density:0.4"
  }
]